# ======================================================================\n# Project Preamble\n# ======================================================================\n# Set a modern CMake version. This is CRITICAL. Version 3.16 or higher\n# enables the modern policies needed for features like IMPORTED targets to\n# work reliably. Using 3.5 forces old, buggy behavior.\ncmake_minimum_required(VERSION 3.16)\n\n# Provide a friendly error message if the user's CMake is too old.\nif(${CMAKE_VERSION} VERSION_LESS 3.16)\n    message(FATAL_ERROR "This project requires CMake 3.16 or higher.")\endif()\nmessage(STATUS "Using cmake version ${CMAKE_VERSION}"  )\n\n# Define the project name, version, and language\nproject(clas12root VERSION 1.9 LANGUAGES CXX)\n\n# ======================================================================\n# Set Project-Wide Build Output Directories\n# ======================================================================\n# The root_generate_dictionary command needs to know\n# where to place the .pcm and .rootmap files. It checks this global variable.\n# By setting it, all libraries and their corresponding ROOT dictionary files\n# will be placed in a consistent "lib" directory inside your build folder.\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\n\n# Set a modern C++ standard. C++17 is a good choice for modern ROOT.\n# Currently leave ROOT to choose standard\n#set(CMAKE_CXX_STANDARD 17)\n#set(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\n# Use PIC for shared libraries and set a default build type if none is specified.\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\nif(NOT CMAKE_BUILD_TYPE)\n  set(CMAKE_BUILD_TYPE Release)\endif()\n\n# ======================================================================\n# Library extension detection (handles .so, .dylib, etc.)\n# ======================================================================\n# Priority for determining the extension:\n# 1) CMake cache variable LIBRARY_EXT (e.g. -DLIBRARY_EXT=.dylib)\n# 2) Environment variable LIB_EXT (e.g. export LIB_EXT=.dylib)\n# 3) CMake-provided CMAKE_SHARED_LIBRARY_SUFFIX (when available)\n# 4) Platform default: .dylib on Apple, .so otherwise\nif(DEFINED LIBRARY_EXT)\n  set(LIBRARY_EXT "${LIBRARY_EXT}")\nelseif(DEFINED ENV{LIB_EXT})\n  set(LIBRARY_EXT "$ENV{LIB_EXT}")\nelseif(DEFINED CMAKE_SHARED_LIBRARY_SUFFIX)\n  set(LIBRARY_EXT "${CMAKE_SHARED_LIBRARY_SUFFIX}")\nelse()\n  if(APPLE)\n    set(LIBRARY_EXT ".dylib")\n  else()\n    set(LIBRARY_EXT ".so")\n  endif()\endif()\nmessage(STATUS "Using shared library extension: ${LIBRARY_EXT}")\n\n# ======================================================================\n# Set Default Installation Prefix from Environment Variable\n# ======================================================================\n\n# This logic sets a default CMAKE_INSTALL_PREFIX based on the CLAS12ROOT\n# environment variable, but ONLY if the user has not already specified one\n# on the command line (e.g., with -DCMAKE_INSTALL_PREFIX=...).\n# The command line always takes priority.\n\nif(DEFINED ENV{CLAS12ROOT})\n    # This checks if the user has NOT provided a -D... flag for the prefix.\n    if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n        # We MUST use FORCE here to overwrite the default /usr/local that CMake\n        # has already put in the cache. This is safe because this whole block\n        # is skipped if the user provides the -D flag.\n        set(CMAKE_INSTALL_PREFIX "$ENV{CLAS12ROOT}" CACHE PATH "Default install path from CLAS12ROOT env variable" FORCE)\n    endif()\endif()\n\n# This message now accurately reports the final installation prefix,\n# whether it came from the default, the environment variable, or the user.\nmessage(STATUS "Installation prefix set to: ${CMAKE_INSTALL_PREFIX}")\n\n# ======================================================================\n# Find Dependencies\n#\n# We find all required packages and define IMPORTED targets for libraries that\n# are not CMake-aware (like HIPO).\n# ======================================================================\n\n# --- 1. Find ROOT ---\n# This single command replaces the old system. It finds ROOT and creates the\n# modern ROOT::* library targets.\n# NOTE: Ensure you have sourced 'thisroot.sh' in your terminal first!\nfind_package(ROOT REQUIRED COMPONENTS\nCore      # Fundamental ROOT classes (TObject, TString, TTree, basic I/O)\n    RIO       # ROOT I/O system (reading/writing .root files, crucial for TTree)\n    Hist      # Histogramming (TH1, TH2, TGraph, etc.)\n    Graf      # Basic graphics primitives (TPolyLine, TMarker, etc.)\n    Graf3d    # 3D Graphics primitives (if you use any 3D drawing)\n    Gpad      # Graphics Pads (TPad), crucial for canvases\n    Gui       # GUI elements (buttons, menus, dialogs - if you have a custom GUI)\n    MathCore  # Basic math functions (e.g., TMath, TLorentzVector)\n    # More advanced/specific components you might need based on your code:\n    Tree      # TTree and related classes (often pulled in by Core, but good to be explicit)\n    Geom      # If you use ROOT's geometry package (TGeo)\n    GenVector # ROOT's vector and physics vector classes (TLorentzVector, etc.)\n    Rint      # The ROOT interactive interpreter. Usually not needed for compiled executables.\n                # Only include this if you explicitly link to the interactive shell for some reason.\n                # It can sometimes pull in many dependencies.\n)\ninclude(${ROOT_USE_FILE})\n\n# --- 2. Find HIPO4 ---\n# Instead of manually setting variables, we check for the HIPO environment\n# variable and create a proper, modern CMake target from it.\nmessage(STATUS "Checking for HIPO4 library...")\nif(DEFINED ENV{HIPO})\n  set(HIPO_INSTALL_DIR $ENV{HIPO})\n  message(STATUS "Found HIPO4 at: ${HIPO_INSTALL_DIR}")\n\n  # Create a modern INTERFACE library target for HIPO.\n  # This encapsulates its usage requirements in a single target: "hipo::hipo"\n  add_library(hipo::hipo INTERFACE IMPORTED)\n  target_include_directories(hipo::hipo INTERFACE ${HIPO_INSTALL_DIR}/include)\n\n  # Try to locate the HIPO library using find_library (portable)\n  find_library(HIPO_LIB\n    NAMES hipo4 libhipo4\n    PATHS ${HIPO_INSTALL_DIR}/lib ${HIPO_INSTALL_DIR}/lib64\n    NO_DEFAULT_PATH\n  )\n\n  if(NOT HIPO_LIB)\n    # Fallback: try constructed filename using detected extension\n    set(HIPO_LIB "${HIPO_INSTALL_DIR}/lib/libhipo4${LIBRARY_EXT}")\n    if(NOT EXISTS "${HIPO_LIB}")\n      message(FATAL_ERROR "Could not find hipo4 library at ${HIPO_INSTALL_DIR}/lib (tried find_library and ${HIPO_LIB}).\nPlease ensure HIPO is set correctly or set LIBRARY_EXT (CMake) or LIB_EXT (env) to the platform library suffix, e.g. .dylib on macOS.")\n    endif()\  endif()\n\n  target_link_libraries(hipo::hipo INTERFACE ${HIPO_LIB})\n\nelse()\n  message(FATAL_ERROR "HIPO environment variable not set. Please set HIPO to point to your hipo4 installation directory.")\endif()\n\n# --- Find External Dependencies (QADB, CCDB, RCDB) ---\n# This logic is now centralized here so that all subdirectories can see\n# the dependency targets we create.\n\n# --- 3. Find QADB ---\nif(DEFINED ENV{QADB})\n    message(STATUS "Configuring dependency: QADB")\n    add_library(clas12::qadb INTERFACE IMPORTED)\n    target_compile_definitions(clas12::qadb INTERFACE -DCLAS_QADB)\n    target_include_directories(clas12::qadb INTERFACE $ENV{QADB}/srcC/include)\n    target_include_directories(clas12::qadb INTERFACE $ENV{QADB}/srcC/rapidjson/include)\n    include_directories($ENV{QADB}/srcC/include)\n    include_directories($ENV{QADB}/srcC/rapidjson/include)\endif()\n\n\n# --- 4. Find CCDB ---\nif(DEFINED ENV{CCDB_HOME})\n    message(STATUS "Configuring dependency: CCDB")\n    add_library(clas12::ccdb INTERFACE IMPORTED)\n    target_include_directories(clas12::ccdb INTERFACE $ENV{CCDB_HOME}/include)\n\n    # Try to locate ccdb library portably\n    find_library(CCDB_LIB\n      NAMES ccdb libccdb\n      PATHS $ENV{CCDB_HOME}/lib $ENV{CCDB_HOME}/lib64\n      NO_DEFAULT_PATH\n    )\n\n    if(NOT CCDB_LIB)\n      # Fallback to constructed filename with detected extension\n      set(CCDB_LIB "$ENV{CCDB_HOME}/lib/libccdb${LIBRARY_EXT}")\n      if(NOT EXISTS "${CCDB_LIB}")\n        message(WARNING "Could not find libccdb in ${ENV{CCDB_HOME}}/lib via find_library or ${CCDB_LIB}. Proceeding without linking an explicit ccdb library; add it manually if needed.")\n        unset(CCDB_LIB)\n      endif()\    endif()\n\n    if(CCDB_LIB)\n      target_link_libraries(clas12::ccdb INTERFACE ${CCDB_LIB})\    endif()\n\    target_compile_definitions(clas12::ccdb INTERFACE -DCLAS_CCDB)\n    include_directories($ENV{CCDB_HOME}/include)\ endif()\n\n\n# --- 5. Find RCDB and MySQL ---\nif(DEFINED ENV{RCDB_HOME})\n    message(STATUS "Configuring dependency: RCDB")\n    add_library(clas12::rcdb INTERFACE IMPORTED)\n    target_include_directories(clas12::rcdb INTERFACE $ENV{RCDB_HOME}/cpp/include)\n    target_compile_definitions(clas12::rcdb INTERFACE -DCLAS_RCDB)\n    include_directories($ENV{RCDB_HOME}/cpp/include)\n\n    find_package(MySQL QUIET)\n\n    if(MySQL_FOUND)\n        message(STATUS "Found MySQL for RCDB support")\n    else()\n     message(STATUS "MySQL not found via find_package. Attempting to locate headers and library manually.")\n\n          # --- Manual Search for MySQL ---\n          # Find MySQL Header (mysql.h)\n          FIND_PATH(MySQL_INCLUDE_DIR\n        mysql.h\n            PATHS\n            /usr/local/include/mysql\n            /usr/include/mysql\n            /opt/homebrew/opt/mysql-client/include # Common Homebrew path\n            /usr/local/Cellar/mysql-client/*/include # More generic Homebrew path\n            "$ENV{MYSQL_HOME}/include" # Check an environment variable hint\n            "$ENV{MYSQL_ROOT}/include"\n            NO_DEFAULT_PATH # Only search the paths explicitly listed\n          )\n\n          # Find MySQL Library (libmysqlclient)\n          FIND_LIBRARY(MySQL_LIBRARIES\n        NAMES mysqlclient libmysqlclient # Common names for the library\n            PATHS\n            /usr/local/lib\n            /usr/lib\n            /usr/lib/x86_64-linux-gnu # Common Linux specific path\n            /opt/homebrew/opt/mysql-client/lib # Common Homebrew path\n            /usr/local/Cellar/mysql-client/*/lib # More generic Homebrew path\n            "$ENV{MYSQL_HOME}/lib"\n            "$ENV{MYSQL_ROOT}/lib"\n            NO_DEFAULT_PATH # Only search the paths explicitly listed\n          )\n\n          # Check if both header and library were found manually\n          if (MySQL_INCLUDE_DIR AND MySQL_LIBRARIES)\n             message(STATUS "MySQL manually found. Header: ${MySQL_INCLUDE_DIR}, Library: ${MySQL_LIBRARIES}")\n          else()\n          # If either part of the manual search failed, report an error\n               message(FATAL_ERROR "MySQL development files not found.\n               Please ensure 'libmysqlclient-dev' (Debian/Ubuntu) or 'mysql-devel' (Fedora/RHEL) or 'mysql-client' (Homebrew) is installed.\n               You may also need to set CMAKE_PREFIX_PATH or MYSQL_ROOT_DIR if installed in a non-standard location.\n               ")\n          endif()\n\n    endif()\n    if (MySQL_INCLUDE_DIR AND MySQL_LIBRARIES)\n        target_include_directories(clas12::rcdb INTERFACE ${MySQL_INCLUDE_DIR})\n        target_link_libraries(clas12::rcdb INTERFACE ${MySQL_LIBRARIES})\n        target_compile_definitions(clas12::rcdb INTERFACE -DRCDB_MYSQL)\n        include_directories(${MySQL_INCLUDE_DIR})\n    endif()\endif()\n\n\n# ======================================================================\n# Installation Rules\n#\n# This section defines how to install the project's products (libraries,\n# executables, headers).\n# ======================================================================\ninclude(GNUInstallDirs)\n\n# ======================================================================\n# Configure Subdirectories\n#\n# We add our sub-projects. The global include_directories() calls have been\n# removed. Each subdirectory is now responsible for defining its own targets\n# and public include paths.\n# ======================================================================\n\nset(HIPOROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/hipo4)\n\n#include_directories(${HIPOROOT_DIR})\n#add_subdirectory (${HIPOROOT_DIR})\nadd_subdirectory(hipo4)\nadd_subdirectory(Clas12Banks)\nadd_subdirectory(Clas12Root)\n\n\n# NOTE: You need to replace "your_lib_target" and "your_exe_target" with the\n# actual names of the targets defined in your subdirectories' CMakeLists.txt files.\n# You can have multiple install() commands.\n\n# Example of installing a library:\n# install(TARGETS Hipo4\n#   ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n#   LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n#   RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n# )\n\n# Example of installing an executable:\n# install(TARGETS your_exe_target\n#   RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n# )\n\n# Example of installing a public header file or directory:\n# install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/Clas12Root/include/\n#   DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n# )\n